<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>vue-diff</title>
</head>
<body>

<script>
    /* 问题:你怎么理解vue中的diff算法？
    *   1.必要性,执行方式,高效性
    *   总结:
    *   diff算法是虚拟dom技术的必然产物,将新旧虚拟dom作比较,最后更新在真是dom中
    *
    *   分析:
    *   vue2.0+里面降低了watcher的颗粒度,一个组件只有一个watcher,所以必须引入diff算法才可以精确地知道哪里发生了变化
    *
    *   vue的diff执行时刻,是执行组件实例的watcher的更新函数的时候,他会对比上一次渲染的dom和新的虚拟dom,这个对比的过程是patch
    *
    *
    *   总结,
    *  在vue2.0中,一个组件只有一个Watcher实例,对应数据变更了,触发同一个watcher的更新函数做视图更新,
    *  其中diff算法就为这个视图更新的逻辑提供了一个高性能的基础
    *
    *  会对比两个阶段之间是文本节点还是元素节点,然后判断是否有子节点,有子节点再优先对节点做处理
    *  会根据假设新旧节点头尾相同的假设,包括用key去判断等,剩下在做遍历,因此patch的过程非常高效
    *
    *
    *
    * 其他语言组织:
    *  diff算法发生在_update函数的调用中,实际发生在patchVnode,就是对两个虚拟dom做比较,并且比较的代码逻辑是深度优先,同级比较的
    *  一般有以下几个判断
    *  1.新老节点都有子节点,对子节点做diff操作,调用updateChildren,通过重排算法给子阶段做重排,并且递归调用patchVnode
    *  2.老节点有子节点,新节点没子节点,删除所有子节点
    *  3.老节点没子节点,新节点有子节点,清空老节点文本内容,然后添加子节点
    *  4.新老节点都没有子节点,文本替换
    * */

</script>
</body>
</html>
